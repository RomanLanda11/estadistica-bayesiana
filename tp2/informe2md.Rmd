---
title: "informe2"
author: "Gazze - Landa - Irisarri"
date: "2024-04-23"
output: html_document
---

```{r}
library(ggplot2)
library(gridExtra)
library(kableExtra)
library(mvtnorm)
```

# Metropolis Hastings en 1D

## 1

```{r}
d_propuesta_def <- function(x, mean){
  dnorm(x, mean, sd= 1)
}

sample_mh <- function (d_objetivo, r_propuesta, d_propuesta = d_propuesta_def, p_inicial, n){
  stopifnot(n>0)
  muestras <- numeric(n)
  muestras[1]<-p_inicial
  for (i in 2:n) {
    p_actual <- muestras[i-1]
    p_nuevo <- r_propuesta(p_actual)
    f_actual <- d_objetivo(p_actual)
    f_nuevo <- d_objetivo(p_nuevo)
    
    q_actual <- d_propuesta(p_actual,mean=p_nuevo)
    q_nuevo <- d_propuesta(p_nuevo,mean=p_actual)
    
    alpha <- min(1, (f_nuevo/f_actual)*(q_actual/q_nuevo))
    
    aceptar <- rbinom(1,1, alpha)
    if (aceptar){
      muestras[i] <- p_nuevo
    } else {
      muestras[i] <- p_actual
    }
    
  }
  return ( muestras ) 
}
```


## Distribución de Kumaraswamy

## 2

```{r}
d_kumaraswamy <- function(x, a ,b){
  if(x<0 || x>1){
    f=0
  }else{
    f <- a*b*(x^(a-1))*(1-x^a)^(b-1)
  }
  return(f)
}
x<-seq(0,1, length.out= 200)
d_kumaraswamy.5.5 <- numeric(length(x))
d_kumaraswamy51<- numeric(length(x))
d_kumaraswamy13 <-numeric(length(x))
d_kumaraswamy22 <- numeric(length(x))
d_kumaraswamy25 <- numeric(length(x))
for (i in 1:length(x)) {
  d_kumaraswamy.5.5[i] <- d_kumaraswamy(x[i], 0.5, 0.5)
  d_kumaraswamy51[i] <- d_kumaraswamy(x[i], 5, 1)
  d_kumaraswamy13[i] <- d_kumaraswamy(x[i], 1, 3)
  d_kumaraswamy22[i] <- d_kumaraswamy(x[i], 2, 2)
  d_kumaraswamy25[i] <- d_kumaraswamy(x[i], 2, 5)
}


df <- data.frame(x,
                 d_kumaraswamy.5.5,
                 d_kumaraswamy51,
                 d_kumaraswamy13,
                 d_kumaraswamy22,
                 d_kumaraswamy25)
ggplot(df, aes(x = x)) +
  # Agregar las líneas para cada distribución
  geom_line(aes(y = d_kumaraswamy.5.5, color = "d_kumaraswamy.5.5")) +
  geom_line(aes(y = d_kumaraswamy51, color = "d_kumaraswamy51")) +
  geom_line(aes(y = d_kumaraswamy13, color = "d_kumaraswamy13")) +
  geom_line(aes(y = d_kumaraswamy22, color = "d_kumaraswamy22")) +
  geom_line(aes(y = d_kumaraswamy25, color = "d_kumaraswamy25")) +
  # Personalizar aspectos del gráfico
  labs(title = "",
       x = "",
       y = "Densidad") +
  scale_color_manual(values = c("d_kumaraswamy.5.5" = "blue",
                                 "d_kumaraswamy51" = "green",
                                 "d_kumaraswamy13" = "red",
                                 "d_kumaraswamy22" = "cyan",
                                 "d_kumaraswamy25" = "purple"),
                     labels = c("d_kumaraswamy.5.5" = "a = 0.5, b = 0.5",
                                "d_kumaraswamy51" = "a = 5, b = 1",
                                "d_kumaraswamy13" = "a = 1, b = 3",
                                "d_kumaraswamy22" = "a = 2, b = 2",
                                "d_kumaraswamy25" = "a = 2, b = 5")) +
  guides(color=guide_legend(title = "Parametros"))+
  theme_minimal()
```
La distribución de Kumaraswamy resulta muy útil a la hora de realizar estudios bayesianos, ya que presenta una es gran flexibilidad y puede modelar una amplia gama de formas de distribución de probabilidad.
Ademas presenta una función de densidad de probabilidad simple y computacionalmente eficiente, lo que facilita su uso en cálculos bayesianos.
(Por último, vale destacar que la restricción al intervalo (0,1) de la distribución de Kumaraswamy resulta útil porque se adapta naturalmente al modelado de proporciones y probabilidades datito*ver)

## 3
```{r}
get_beta_pars <- function(mu, kappa){
  alpha <- mu *kappa
  beta <- (1-mu)*kappa
  return(list(alpha = alpha, beta = beta))
}
#graficar kumaraswamy 6 2, y una beta 8,2 para mostrar que son parecidas
d_objetivo <- function(x, a=6 ,b=2){
  if(x<0 || x>1){
    f=0
  }else{
    f <- a*b*(x^(a-1))*(1-x^a)^(b-1)
  }
  return(f)
}
kappas <- c(1,25,50)
n=5000
muestras <- matrix(nrow = n,ncol = length(kappas))
for (i in 1:3) {
  #p_inicial = runif(1) se agrega?
  r_propuesta <- function(x) {
    kappa <- kappas[i]
    pars <- get_beta_pars(x, kappa)
    rbeta(1, pars$alpha, pars$beta)
  }
  d_propuesta <- function(x, mean) {
    kappa <- kappas[i]
    pars <- get_beta_pars(mean, kappa)
    dbeta(x, pars$alpha, pars$beta)
  }
  p_inicial <- runif(1)
  
  muestras[,i] <- sample_mh(d_objetivo, r_propuesta, d_propuesta, p_inicial= p_inicial, n=n)
}


df <- as.data.frame(cbind(muestras, x=1:n))
ggplot(df, aes(x = x)) +
  geom_line(aes(y = V1), color = "blue") +
  geom_line(aes(y = V2), color = "red") +
  geom_line(aes(y = V3), color = "green") +
  labs(x = "Eje X", y = "Valores", title = "Gráfico de Líneas para V1, V2 y V3")

# o bien
g1 <- ggplot(df, aes(x = x, y = V1)) +
  geom_line(color = "blue") +
  labs(x = "", y = "V1", title = "")

# Graficar V2
g2 <- ggplot(df, aes(x = x, y = V2)) +
  geom_line(color = "red") +
  labs(x = "", y = "V2", title = "")

# Graficar V3
g3 <- ggplot(df, aes(x = x, y = V3)) +
  geom_line(color = "green") +
  labs(x = "", y = "V3", title = "")
grid.arrange(g1,g2,g3,ncol=1)
```

```{r}
g1 <- ggplot(df, aes(x = V1)) +
  geom_histogram(color = "black", fill = "blue", bins = 30) +
  labs(x = "", y = "Frecuencia", title = "Histograma para V1")+
  coord_cartesian(xlim = c(0, 1), ylim = c(0, 500))

# Graficar histograma para V2
g2 <- ggplot(df, aes(x = V2)) +
  geom_histogram(color = "black", fill = "red", bins = 30) +
  labs(x = "", y = "Frecuencia", title = "Histograma para V2")+
  coord_cartesian(xlim = c(0, 1), ylim = c(0, 500))

# Graficar histograma para V3
g3 <- ggplot(df, aes(x = V3)) +
  geom_histogram(color = "black", fill = "green", bins = 30) +
  labs(x = "", y = "Frecuencia", title = "Histograma para V3")+
  coord_cartesian(xlim = c(0, 1), ylim = c(0, 500))

# Mostrar los histogramas en una sola columna
grid.arrange(g1, g2, g3, ncol = 1)
```

```{r}
# averiguar si hay grafico para el correlograma

calcular_w <- function(x){
  mean(apply(x, 2, var))
}

calcular_b <- function(x){
  media_chain <- apply(x, 2, mean)
  var(media_chain) * nrow(x)
}

R_hat <- function(x){
  S <- nrow(x)
  M <- ncol(x)
  W <- calcular_w(x)
  B <- calcular_b(x)
  numerador <- (S-1)/S * W + (1 / S) * B
  sqrt(numerador / W)
}

R_hat(muestras)
```

```{r}
autocorr <- acf(muestras[,3], plot = TRUE, lag = Inf)$plot
# mejorar graficos
N_eff <- function(x){
  S <- length(x)
  autocorr <- acf(x, plot = FALSE, lag = Inf)$acf
  limite <- which(autocorr<0.05)[1]
  
  denominador <- 1 + 2 * sum(autocorr[2:limite])
  S / denominador  
}
N_eff(muestras[,1])
N_eff(muestras[,2])
N_eff(muestras[,3])
# no parecen muy bajos para 5k muestras
```


## 4

```{r}
medias <- c(mean(muestras[,1]),mean(muestras[,2]),mean(muestras[,3]))
percentiles<- rbind(quantile(muestras[,1], c(0.05, 0.95)),
                    quantile(muestras[,2], c(0.05, 0.95)),
                    quantile(muestras[,3], c(0.05, 0.95)))

tabla <-cbind(medias, percentiles)
colnames(tabla) <- c("Medias","Percentil 5", "Percentil 95")
rownames(tabla) <- c("Kappa = 1","Kappa = 25", "Kappa = 50")
kable(round(tabla,3))%>% 
  kable_styling(position = "center",full_width = FALSE) %>% 
  row_spec(0, bold = T, background = "gray", color = "black") 
```

```{r}
muestras_logit <- log(muestras/(1-muestras))
medias_logit <- c(mean(muestras_logit[,1]),mean(muestras_logit[,2]),mean(muestras_logit[,3]))
percentiles_logit <- rbind(quantile(muestras_logit[,1], c(0.05, 0.95)),
                    quantile(muestras_logit[,2], c(0.05, 0.95)),
                    quantile(muestras_logit[,3], c(0.05, 0.95)))

tabla_logit <-cbind(medias_logit, percentiles_logit)
colnames(tabla_logit) <- c("Medias","Percentil 5", "Percentil 95")
rownames(tabla_logit) <- c("Kappa = 1","Kappa = 25", "Kappa = 50")
kable(round(tabla_logit,3))%>% 
  kable_styling(position = "center",full_width = FALSE) %>% 
  row_spec(0, bold = T, background = "gray", color = "black") 
```

# Metropolis-Hastings en 2D

## 6

```{r}
sample_mh_2d <- function (d_objetivo, r_propuesta, d_propuesta, p_inicial, n, sigma_prop){
  stopifnot(n>0)
  muestras <- matrix(nrow = n, ncol = length(p_inicial))
  muestras[1,]<-p_inicial
  for (i in 2:n) {
    p_actual <- muestras[i-1,]
    p_nuevo <- r_propuesta(p_actual)
    f_actual <- d_objetivo(p_actual)
    f_nuevo <- d_objetivo(p_nuevo)
    
    q_actual <- d_propuesta(p_actual,mean=p_nuevo)
    q_nuevo <- d_propuesta(p_nuevo,mean=p_actual)
    
    alpha <- min(1, (f_nuevo/f_actual)*(q_actual/q_nuevo))
    
    aceptar <- rbinom(1,1, alpha)
    if (aceptar){
      muestras[i,] <- p_nuevo
    } else {
      muestras[i,] <- p_actual
    }
    
  }
  return ( muestras ) 
}


```

## 7

```{r, warning=FALSE}
mu_obj <- c(0.4, 0.75)
sigma_obj <- matrix(c(1.35, 0.4, 0.4, 2.4), ncol = 2)

sigma_prop <- diag(2) #preguntar esto

d_objetivo <- function(x) dmvnorm(x, mean = mu_obj, sigma = sigma_obj)
r_propuesta <- function(x) rmvnorm(1, mean = x, sigma = sigma_prop)
d_propuesta <- function(x, mean) dmvnorm(x, mean = mean, sigma = sigma_prop)

muestras_2d <- sample_mh_2d(d_objetivo, r_propuesta, d_propuesta, p_inicial= c(1, 1), n=1000)

df_grilla <- expand.grid(x = seq(-3, 3, length.out = 200), seq(-3, 3, length.out = 200))
df_grilla$z <- d_objetivo(as.matrix(df_grilla))

muestras_2d_df <- as.data.frame(muestras_2d)
ggplot(muestras_2d_df, aes(x = V1, y = V2)) +
  geom_density_2d(fill = "skyblue", alpha = 0.5) +
  geom_density2d_filled()+
  geom_point(data = muestras_2d_df, aes(x = V1, y = V2), color = "cyan2", alpha = 0.1) +
  labs(title = "Gráfico de Densidad en Dos Dimensiones",
       x = "Valor 1",
       y = "Valor 2") +
  stat_contour(aes(x = x, y = Var2, z = z), data = df_grilla, color = "white")+
  theme_minimal()

# p_inicial = rmvnorm(1,mean=c(1,1)) ?
```


```{r}

########################
plot_trace <- function(x, y){
  n <-length(x)
  df <- data.frame(x = rep(1:n, 2), y = c(x, y), dimension = rep(1:2, each = n))
  ggplot(df)+
    geom_line(aes(x = x, y = y))+
    facet_grid(rows = vars(dimension))
}  

plot_trace(muestras_2d_df$V1, muestras_2d_df$V2)


#Número efectivo de muestras
N_eff(muestras_2d[,1]) #Variable 1
N_eff(muestras_2d[,2]) #Variable 2

```

