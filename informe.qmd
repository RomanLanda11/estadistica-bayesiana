---
title: " Trabajo Práctico 1: The Multiarmed Bandit "
author: "Landa - Irisarri - Gazze"
format:
  html:
    self-contained: true
    toc: true
    toc-title: "Tabla de Contenidos"
    number-sections: true
    code-fold: true
    highlight-style: pygments
    html-math-method: katex
    code-copy: true
    code-tools: true
    grid: # TODO: ir modificando.. (con otro documento más corto)
      body-width: 2000px # cuerpo documento
      sidebar-width: 100px # margen lateral en blanco
      margin-width: 350px # tabla de contenido
  pdf:
execute:
  warning: false
---

## Introducción:

Se presenta el problema del tipo "*multi-armed bandit", en el cual se desea elegir entre tres máquinas tragamonedas, con el propósito de maximizar las ganancias.* El juego de las maquinitas consiste en hacer girar sus rodillos (analógicos o digitales) con el objetivo de obtener una combinación de símbolos ganadora y así acceder a un premio monetario.

Cada máquina tiene una probabilidad de éxito desconocida y potencialmente diferente, es decir, una probabilidad distinta de entregar un premio. Este es un desafío que enfrenta a los jugadores con la decisión de explotar lo conocido o explorar lo desconocido para maximizar sus ganancias, donde la información es clave pero limitada: cada tirada de una máquina revela un poco más sobre su rendimiento, pero también podría cambiar tu percepción sobre cuál es la mejor opción.

En la fase inicial, cuando se sabe poco sobre las máquinas, podría ser más prudente *"explorar"*, probando cada máquina varias veces para obtener una estimación aproximada de sus probabilidades de éxito. A medida que se acumulan datos sobre el rendimiento de cada máquina, la estrategia podría cambiar a *"explotar"* la máquina que ha demostrado ser la más rentable. Sin embargo, siempre existe la incertidumbre y la posibilidad de que una de las máquinas menos utilizadas tenga en realidad una tasa de éxito mayor. Este problema se complica aún más por el hecho de que cada elección de máquina proporciona información que podría alterar nuestra comprensión de cuál es la mejor opción. La solución óptima a este problema involucra un equilibrio cuidadoso entre explorar para ganar información y explotar esa información para maximizar las ganancias.

En nuestro escenario, no hay costo para jugar, lo que significa que no pierdes nada al jugar con una máquina. Es decir, si obtenemos una combinación ganadora, sumamos una unidad monetaria, pero si no, no perdemos nada. En este estudio se realizará un año de experimentación continua (366 días), dedicando cada día a una sola máquina.

![Adultos mayores usufructuando las diferentes estrategias](adultos_jugando.jpg)

## Objetivos:

El objetivo del trabajo consiste en evaluar y comparar diferentes estrategias de juego. Se analizarán mediante simulaciones diferentes planes de exploración y explotación de las máquinas para identificar cuál de estos proporciona la mayor ganancia esperada.

Para el estudio mediante simulaciones, consideraremos que las probabilidades de éxito de las tres máquinas son $\theta_a = 0.30$, $\theta_b = 0.55$ y $\theta_c = 0.45$. Recordemos que estas probabilidades son desconocidas (no podemos basar nuestras estrategias en esos valores, sino en las estimaciones que vamos haciendo de ellos).

## Desarrollo

A continuación se presenta el análisis de las siete estrategias estudiadas. Para todas ellas, se parte de una ditribución a priori de la probabilidad de éxito de cada máquina Beta(2, 2).

```{r, echo=FALSE, warning=FALSE, error=FALSE}
# Carga de paquetes necesarios
library(ggplot2)
library(dplyr)
library(cowplot)
library(gridExtra)
set.seed(491)

# Gráfico de prior 
library(ggplot2)
library(cowplot)
library(gridExtra)
x <- seq(0, 1, length.out = 200)
prior1 <- dbeta(x, 2, 2)
prior2 <- dbeta(x, 2, 2)
prior3 <- dbeta(x, 2, 2)

g1<-ggplot(x = x, y = prior1)+
  aes(x = x, y = prior1)+
  geom_line( color = "#FF6699") +
  geom_area(fill = "lightpink", alpha = 0.4, position = "identity") +
  labs(x = bquote(theta[1]), y = expression("p(" ~ theta[1] ~ "| y)")) + 
  theme(legend.position = "none")

g2<-ggplot(x = x, y = prior2)+
  aes(x = x, y = prior2)+
  geom_line( color = "darkgreen") +
  geom_area(fill = "lightgreen", alpha = 0.4, position = "identity") +
  labs(x = bquote(theta[2]), y = expression("p(" ~ theta[2] ~ "| y)")) +
  theme(legend.position = "none")


g3<-ggplot(x = x, y = prior3)+
  aes(x = x, y = prior3)+
  geom_line( color = "darkblue") +
  geom_area(fill = "lightblue", alpha = 0.4, position = "identity") +
  labs(x = bquote(theta[3]), y = expression("p(" ~ theta[3] ~ "| y)")) +
  theme(legend.position = "none")

grid.arrange(g1, g2, g3, ncol = 3)
```

#### *Estrategia 1: Completamente al azar*

En esta estrategia cada día se juega con una máquina seleccionada al azar con igual probabilidad.

```{r, echo=FALSE, warning=FALSE, error=FALSE}
# Funciones necesarias
graficar<-function(cont_tiradas, cont_exitos, wins, alphas, betas){
  df <- data.frame(maq = c("Maquina 1", "Maquina 2", "Maquina 3"),
                   freq = cont_tiradas,
                   exitos = cont_exitos,
                   fracasos = cont_tiradas - cont_exitos)
  g1<-ggplot(df, aes(x = maq, fill = maq)) +
    geom_bar(aes(y = freq ), stat = "identity", color = "black") +
    geom_bar(aes(y = exitos ), stat = "identity", color = "black") +
    geom_text(aes(y = exitos, label = "Éxitos"), position = position_stack(vjust = 0.5)) +
    geom_text(aes(y = freq, label = "Fracasos"), position = position_stack(vjust = 0.8)) +
    labs(x = "Máquinas",
         y = "Frecuencia") +
    theme_minimal() +
    guides(fill = guide_legend(title = "Máquinas"))
  
  
  # Crear el gráfico de ganancias
  df <- data.frame(dias = 1:366, wins=wins)
  g2<-ggplot(df, aes(x = dias, y = wins)) +
    geom_line(color = "blue")+
    labs(x = "Día",
         y = "Valor acumulado")
  
  # Crear el gráfico de postiriors
  x1=seq(0,1,length.out =200)
  posterior1=dbeta(x1,alphas[1],betas[1])
  posterior2=dbeta(x1,alphas[2],betas[2])
  posterior3=dbeta(x1,alphas[3],betas[3])
  
  df <- data.frame(
    theta = x1,
    posterior = rep(c(posterior1,posterior2, posterior3), time = 1),
    maquina = rep(c("Maquina 1", "Maquina 2", "Maquina 3"), each = length(x1))
  )
  
  g3<-ggplot(df)+
    aes(x = theta, y = posterior, color = maquina)+
    theme(legend.position = "right")+
    geom_line() +
    geom_area(aes(fill = maquina), alpha = 0.4, position = "identity") +
    labs(x = expression(theta), y = expression("p(" ~ theta ~ "| y)"))
print(g1)
print(g3)
print(g2)
}
```

Se presenta la función creada para simular la elección de una máquina y su respectiva tirada. A esta se le envia una lista con los parámetros necesarios como $\theta$ o probabilidad de éxito real de cada máquina, $\alpha$ y $\beta$ parámetros de las distribuciones a priori, etc. La función decide, como bien indica su nombre, una de las tres máquinas de manera al azar y simula la jugada con esa máquina. Luego nos devuelve los valores actualizados de los parámetros.

```{r, error=FALSE, warning=FALSE, echo=TRUE}
al_azar <- function(lista1) {
  alphas <- lista1[[1]]
  betas <- lista1[[2]]
  tethas <- lista1[[3]]
  prior_df <- lista1[[4]]
  x1=seq(0,1,length.out =200)

  sample <- sample(1:length(alphas), 1)
  juego <- rbinom(1, 1, tethas[sample])
  alphas[sample] <- alphas[sample] + juego
  betas[sample] <- betas[sample] + 1 - juego
  
  postirior <- dbeta(x1, alphas[sample],  betas[sample])
  prior_df[, sample] <- postirior
  salida1_list <- list(alphas, betas, tethas, prior_df, sample, juego)
  return(salida1_list)
}
```

Luego, se utiliza esta función para simular las jugadas diarias durante un año. A partir de esta información se registró la evolución diaria del dinero acumulado cada día, la cantidad de veces que se jugó con cada máquina y la distribución a posteriori de la probabilidad de éxito para cada máquina.

```{r, error=FALSE, warning=FALSE, echo=FALSE}
set.seed(491)
alphas<-c(2,2,2)
betas<-c(2,2,2)
tethas=c(0.3,0.55,0.45)

x1=seq(0,1,length.out =200)
prior_df <- data.frame(prior1=dbeta(x1,alphas[1],betas[1]), 
                       prior2=dbeta(x1,alphas[2],betas[2]), 
                       prior3=dbeta(x1,alphas[3],betas[3]))

wins=numeric(366)
cont_exitos= c(0,0,0)
cont_tiradas = c(0, 0, 0)
juego=0
sample=0
entrada1_list = list(alphas, betas, tethas, prior_df, sample, juego)
graf_list=list()

for (i in 1:366) {
  entrada1_list=al_azar(lista1=entrada1_list)
  sample <- entrada1_list[[5]]
  juego <- entrada1_list[[6]]
  cont_exitos[sample] <- cont_exitos[sample] + juego
  cont_tiradas[sample] <- cont_tiradas[sample] + 1
  prior_df <- entrada1_list[[4]]

  if(i==1){
    wins[i]=juego
  }else{
    wins[i]=wins[i-1]+juego
  }
  prior_df_largo <- data.frame(
    theta = x1,
    posterior = rep(c(prior_df$prior1, 
                      prior_df$prior2, 
                      prior_df$prior3), time = 1),
    maquina = rep(c("Maquina 1", "Maquina 2", "Maquina 3"), each = 200)
  )
  graf_list[[i]] <- ggplot(prior_df_largo)+
    aes(x = theta, y = posterior, color = maquina)+
    theme(legend.position = "none")+
    geom_line() +
    geom_area(aes(fill = maquina), alpha = 0.4, position = "identity") +
    labs(x = expression(theta), y = expression("p(" ~ theta ~ "| y)"))
}

grid.arrange(graf_list[[1]],graf_list[[2]],graf_list[[3]],graf_list[[4]],
             graf_list[[363]],graf_list[[364]],graf_list[[365]],graf_list[[366]],
             ncol = 4)


# Crear el gráfico de barras
df <- data.frame(maq = c("Maquina 1", "Maquina 2", "Maquina 3"),
                 freq = cont_tiradas,
                 exitos = cont_exitos,
                 fracasos = cont_tiradas - cont_exitos)
ggplot(df, aes(x = maq, fill = maq)) +
  geom_bar(aes(y = freq ), stat = "identity", color = "black") +
  geom_bar(aes(y = exitos ), stat = "identity", color = "black") +
  geom_text(aes(y = exitos, label = "exitos"), position = position_stack(vjust = 0.5)) +
  geom_text(aes(y = freq, label = "fracasos"), position = position_stack(vjust = 0.8)) +
  labs(title = "Comparación de frecuencias",
       x = "Máquina",
       y = "Frecuencia") +
  theme_minimal() +
  guides(fill = guide_legend(title = "Máquinas"))


df <- data.frame(dias = 1:366, wins=wins)

# Crear el gráfico evolucion ganancia
ggplot(df, aes(x = dias, y = wins)) +
  geom_line(color = "blue")+
  labs(title = "Valores acumulados en 366 días",
       x = "Día",
       y = "Valor acumulado")

```

Se observa que las distribuciones a posteriori de las probabilidades de éxito de cada máquina se van centrando en el verdadero valor del parámetro a medida que aumenta la cantidad de días jugados.  
En el gráfico de barras se observa que se jugó de manera parecida con las tres máquinas esto se debe a que la elección de las mismas se realiza de manera aleatoria, sin tener en cuenta lo ocurrido anteriormente. Puede observarse que la máquina 2 es la que proporciona un mayor cantidad de éxitos, mientras que la 1 parece ser la peor.
Luego de un año de simulaciones, se obtuvo una ganancia de 159 unidades monetarias.

El mismo procedimiento realizado para un año se repite por un período de 1000 años. A continuación se presentan los resultados.

```{r, echo=FALSE, error=FALSE, warning=FALSE}
n_simulaciones = 1000
wins1_anio = numeric(n_simulaciones)

for (anio in 1:n_simulaciones) {
  alphas<-c(2,2,2)
  betas<-c(2,2,2)
  tethas=c(0.3,0.55,0.45)
  x1=seq(0,1,length.out =200)
  prior_df <- data.frame(prior1=dbeta(x1,alphas[1],betas[1]), 
                         prior2=dbeta(x1,alphas[2],betas[2]), 
                         prior3=dbeta(x1,alphas[3],betas[3]))
  wins=numeric(366)
  cont_exitos= c(0,0,0)
  cont_tiradas = c(0, 0, 0)
  juego=0
  sample=0
  entrada1_list = list(alphas, betas, tethas, prior_df, sample, juego)
  graf_list=list()
  
  for (i in 1:366) {
    entrada1_list=al_azar(lista1=entrada1_list)
    sample <- entrada1_list[[5]]
    juego <- entrada1_list[[6]]
    cont_exitos[sample] <- cont_exitos[sample] + juego
    cont_tiradas[sample] <- cont_tiradas[sample] + 1
    prior_df <- entrada1_list[[4]]
    
    if(i==1){
      wins[i]=juego
    }else{
      wins[i]=wins[i-1]+juego
    }
  }
  wins1_anio[anio] <- wins[366]
}

ganacias_df <- data.frame(anios=1:n_simulaciones, ganacias=wins1_anio)
ggplot(ganacias_df) +
  aes(x = ganacias) +
  geom_histogram(aes(y = ..density..), color = "black", fill = "lightblue", bins = 30) +
  geom_density(color = "blue", size = 1)

print(paste("La ganancia media por año es ",mean(ganacias_df$ganacias),"unidades monetarias"))

```

A traves de la simulación de los 1000 años, se observa la distribución de las ganancias, la cual presenta un comportamiente simétrico centrado en aproximadamente 160 unidades monetarias por año.

Por último se concluye que esta estrategia no podria considerarse bayesiana, ya que siempre elige la máquina a utilizar de manera aleatoria, sin tener en cuenta la información recolectada.

#### *Estrategia 2: Greedy con tasa observada*

En esta estrategia se elige la máquina que tenga la mayor tasa de éxito observada hasta el momento. Esta tasa para cada máquina la calculamos como cantidad de días ganados sobre días jugados. Partiendo de una creencia inicial de que las tasas de éxito para las tres máquinas son iguales a 0.5. 
Con esta técnia se corre el riesgo de perder la primera vez que se juega con una máquina, su tasa se actualice a cero y no volver a utilizarla. Para omitir estos casos realizamos 10 tiradas de calentamiento previamente.

Se presenta la función que replica esta estrategia para un día. A esta se le envia una lista con los parámetros necesarios. La función elige de manera aleatoria la máquina a utilizar si el día simulado se encuentra entre los primeros 10, en los restantes elige la que presenta mayor tasa de éxito, simula la jugada y luego nos devuelve los valores actualizados de los parámetros.

```{r, echo=TRUE, error=FALSE, warning=FALSE}
greedy_tasa_obs<-function(lista2){
  fl_calentamiento <- lista2[[5]]
  t <- lista2[[2]]
  tethas <- lista2[[1]]
  if (fl_calentamiento){
    sample <- sample(1:3, 1)
  }
  else{
    sample <- order(t + runif(3,0.001, 0.009), decreasing = TRUE)[1]
  }
  juego <- rbinom(1, 1, tethas[sample])
  lista2_salida<-list(tethas, t, juego, sample, fl_calentamineto)
  return(lista2_salida)
}

```

Aplicando este procedimiento para simular cada día jugado del año obtenemos:

```{r, echo=FALSE, error=FALSE, warning=FALSE}
# Defino variables necesarias
tethas=c(0.3,0.55,0.45)
t = c(0.5,0.5,0.5)
cont_exitos= c(0,0,0)
cont_tiradas = c(0, 0, 0)
juego=0
sample=0
fl_calentamineto=FALSE
wins=numeric(366)
lista2_entrada=list(tethas, t, juego, sample, fl_calentamineto)

for(i in 1:366){
  fl_calentamineto <- ifelse(i>10, FALSE, TRUE )

  lista2_entrada <- greedy_tasa_obs(lista2 = lista2_entrada)
  juego <- lista2_entrada[[3]]
  sample <- lista2_entrada[[4]]
  cont_exitos[sample] <- cont_exitos[sample] + juego
  cont_tiradas[sample] <- cont_tiradas[sample] + 1
  lista2_entrada[[2]][sample] <- cont_exitos[sample] / cont_tiradas[sample]
  if(i==1){
    wins[i]=juego
  }else{
    wins[i]=wins[i-1]+juego
  }
}

alphas <- c(2+cont_exitos[1], 2+cont_exitos[2], 2+cont_exitos[3])
betas <- c(2+cont_tiradas[1]-cont_exitos[1],
           2+cont_tiradas[2]-cont_exitos[2],
           2+cont_tiradas[3]-cont_exitos[3])
# Graficos
graficar(cont_tiradas, cont_exitos, wins, alphas, betas)
print(paste("La ganancia de este año es ",wins[366],"unidades monetarias"))
```

Se observa que este método en el año simulado elige mayormente la máquina 2, esto se debe a que presentó una mayor tasa de éxitos y se mantuvo constante durante este tiempo.
En el gráfico de las distribuciones a posteriori se ve que la más modificada es la correspondiente a la máquina dos, debido a que ésta fue la más utilizada. Además se nota que se concentra alrededor del verdadero valor poblacional ($\theta_2 = 0.55$).
Se presenta un tercer gráfico con la evolución de las ganancias acumuladas durante el año.

Luego se repite este procedimiento para simular 1000 años jugados con esta estrategia y se analizan los resultados.

```{r, echo=FALSE, warning=FALSE, error=FALSE}
wins2_anio = numeric(n_simulaciones)

for (anio in 1:n_simulaciones) {
  # Definimos parametros
  tethas=c(0.3,0.55,0.45)
  t = c(0.5,0.5,0.5)
  cont_exitos= c(0,0,0)
  cont_tiradas = c(0, 0, 0)
  juego=0
  sample=0
  fl_calentamineto=TRUE
  wins=numeric(366)
  lista2_entrada=list(tethas, t, juego, sample, fl_calentamineto)
  #Simulamos anio
  for(i in 1:366){
    fl_calentamineto <- ifelse(i>10, FALSE, TRUE )
    
    lista2_entrada <- greedy_tasa_obs(lista2 = lista2_entrada)
    juego <- lista2_entrada[[3]]
    sample <- lista2_entrada[[4]]
    cont_exitos[sample] <- cont_exitos[sample] + juego
    cont_tiradas[sample] <- cont_tiradas[sample] + 1
    lista2_entrada[[2]][sample] <- cont_exitos[sample] / cont_tiradas[sample]
    if(i==1){
      wins[i]=juego
    }else{
      wins[i]=wins[i-1]+juego
    }
  }
  wins2_anio[anio] <- wins[366]
}

ganacias_df <- data.frame(anios=1:n_simulaciones, ganacias=wins2_anio)
ggplot(ganacias_df) +
  aes(x = ganacias) +
  geom_histogram(aes(y = ..density..), color = "black", fill = "lightblue", bins = 30) +
  geom_density(color = "blue", size = 1)
```
```{r, echo=FALSE, error=FALSE, warning=FALSE}
mean(ganancia_df$wins)
```

Se grafica la distribución aproximada de la ganancia anual. En este se diferencian tres modas, estas corresponden a la cantidad de años en los cuales se usaron mayormente las máquinas 1, 3 y 2 respectivamente.
La media de las ganancias anuales es 185.1 unidades monetarias.
Además se puede notar que mayormente se obtuvieron ganancias altas, por lo que suponemos que se utilizó en mayor medida la máquina dos.

El método, sin tener en cuenta las primeras 10 tiradas, es bayesiano ya que utiliza la máquina con mayor tasa de éxito y estas se actualizan en base a los resultados obtenidos tirada tras tirada.

#### *Estrategia 3: Greedy con probabilidad a posteriori*

En esta estrategia se elige la máquina que tenga, hasta el momento, mayor probabilidad de éxito promedio a posteriori. 

Se presenta la función que simula esta estrategia para un día.Para esto se calculan las esperanzas de las tres distribuciones a priori y se utiliza la máquina que presenta el mayor valor.Luego se simula el juego con la máquina elegida y se actualizan las distribuciones.

```{r, echo=TRUE, error=FALSE, warning=FALSE}
greedy_prob_posterior<-function(lista3){
  tethas <- lista3[[1]]
  alphas <- lista3[[2]]
  betas <- lista3[[3]]
  
  esperanzas = c(alphas[1]/(alphas[1]+betas[1]),
                alphas[2]/(alphas[2]+betas[2]),
                alphas[3]/(alphas[3]+betas[3]))
  #print(esperanzas)
  sample <- order(esperanzas + runif(3,0.001, 0.009)  , decreasing = TRUE)[1]
  juego <- rbinom(1, 1, tethas[sample])
  alphas[sample] <- alphas[sample] + juego
  betas[sample] <- betas[sample] + 1 - juego
  
  lista3_salida<-list(tethas, alphas, betas, juego, sample)
  return(lista3_salida)
}
```

Reiterando este método para simular las jugadas de un año se obtiene:

```{r, echo=FALSE, error=FALSE, warning=FALSE}
# Defino variables necesarias
set.seed(492)
tethas=c(0.3,0.55,0.45)
alphas<-c(2,2,2)
betas<-c(2,2,2)
juego=0
sample=0
cont_exitos= c(0,0,0) 
cont_tiradas = c(0, 0, 0)

wins=numeric(366)
lista3_entrada=list(tethas, alphas, betas, juego, sample)

for(i in 1:366){
  lista3_entrada <- greedy_prob_posterior(lista3 = lista3_entrada)
  juego <- lista3_entrada[[4]]
  alphas <- lista3_entrada[[2]]
  betas <- lista3_entrada[[3]]
  sample <- lista3_entrada[[5]]
  cont_exitos[sample] = cont_exitos[sample] + juego 
  cont_tiradas[sample] = cont_tiradas[sample] + 1
  if(i==1){
    wins[i]=juego
  }else{
    wins[i]=wins[i-1]+juego
  }
}
alphas <- lista3_entrada[[2]]
betas<- lista3_entrada[[3]]
# Graficos
graficar(cont_tiradas, cont_exitos, wins, alphas, betas)
print(paste("La ganancia de este año es ",wins[366],"unidades monetarias"))
```

Se observa que la máquina más utilizada es la número dos presentando la mayor esperanza en su distribucion a posteriori.
Viendo las distribuciones a posteriori se puede notar que los valores de la máquina 2 está más concentrada alrededor de 0.55. Mientras que para las máquinas 2 y 3 la dispersión de los valores es mayor, esto se debe a que estas máquinas fueron las menos utilizadas.
Con el último gráfico se observa la evolución de las ganancias a traves del paso de los días, obteniendo una ganancia total de 202 unidades monetarias.

Luego se repite este procedimiento para simular 1000 años jugados con esta estrategia y se analizan los resultados.

```{r, echo=FALSE, warning=FALSE, error=FALSE}
wins3_anio=numeric(n_simulaciones)
for (anio in 1:n_simulaciones) {
  # Defino variables necesarias
  tethas=c(0.3,0.55,0.45)
  alphas<-c(2,2,2)
  betas<-c(2,2,2)
  juego=0
  sample=0
  cont_exitos= c(0,0,0) 
  cont_tiradas = c(0, 0, 0)
  
  wins=numeric(366)
  lista3_entrada=list(tethas, alphas, betas, juego, sample)
  
  for(i in 1:366){
    lista3_entrada <- greedy_prob_posterior(lista3 = lista3_entrada)
    juego <- lista3_entrada[[4]]
    alphas <- lista3_entrada[[2]]
    betas <- lista3_entrada[[3]]
    sample <- lista3_entrada[[5]]
    cont_exitos[sample] = cont_exitos[sample] + juego 
    cont_tiradas[sample] = cont_tiradas[sample] + 1
    if(i==1){
      wins[i]=juego
    }else{
      wins[i]=wins[i-1]+juego
    }
  }
  wins3_anio[anio]<-wins[366]
}

ganancia_df <- data.frame(wins = wins3_anio)
ggplot(ganancia_df) +
  aes(x = wins) +
  geom_histogram(aes(y = ..density..), color = "black", fill = "lightblue", bins = 30) +
  geom_density(color = "blue", size = 1)
```

```{r}
mean(ganancia_df$wins)
```

Luego de simular 1000 años, se grafican las ganancias anuales y se observa una distribución bimodal con modas aproximadamente en 160 y 190 unidades monetarias, correspondientes a las maquinas 3 y 2 respectivamente.La ganancia media para los 1000 años de simulación resulta igual a 189.17 unidades monetarias.
El método es bayesiano ya que utiliza la máquina con mayor probabilidad de exito promedio y estas se actualizan en base a los resultados obtenidos tirada tras tirada.


#### *Estrategia 4: $\epsilon$ -greedy (con tasa observada)*

Se selecciona la mejor máquina (la de mayor tasa de éxito observada según los datos actuales) con una probabilidad de $\epsilon$ y se elige una máquina al azar con una probabilidad $1-\epsilon$. En este contexto, $\epsilon$ es una constante que varía entre 0 y 1, y su valor determina la proporción de tiempo que el jugador dedicará a la exploración en comparación con la explotación. 

Se presenta la función que simula esta estrategia para un día.


```{r}
e_greedy_tasa_obs<-function(lista4){
  e<-lista4[[3]]
  explote<-runif(1)
  lista4[[6]] = 0
  lista4[[7]] = 0
  if(explote<=1-e){#Elige el mejor
    lista4[[7]] = 1 # exploto
    sample <-  order(t + runif(3,0.001, 0.009), decreasing = TRUE)[1]
  }else{#Elige aleatoriamente 
    lista4[[6]] = 1 # exploro
    sample <-  as.numeric(sample(1:3, 1))
  }

  juego <- rbinom(1, 1, tethas[sample])
  lista4_salida<-list(tethas, t, e, juego, sample, lista4[[6]], lista4[[7]])
  return(lista4_salida)
}


```

Se elige un $\epsilon=0.05$, esto significa que el jugador gastará el 5% de su tiempo explorando nuevas máquinas y el 95% restante explotando la máquina que ha demostrado ser más rentable hasta ese momento. Reiterando este método para simular las jugadas de un año se obtiene:
```{r}
set.seed(491)
e=0.05
# Defino variables necesarias
tethas=c(0.3,0.55,0.45)
t = c(0.5,0.5,0.5)
cont_exitos= c(0,0,0) 
cont_tiradas = c(0, 0, 0)
juego=0
sample=0
exploro=0
exploto=0
wins=numeric(366)
lista4_entrada=list(tethas, t, e, juego, sample, exploro, exploto)

for(i in 1:366){
  lista4_entrada <- e_greedy_tasa_obs(lista4 = lista4_entrada)
  juego <- lista4_entrada[[4]]
  sample <- lista4_entrada[[5]]
  exploro <- exploro + lista4_entrada[[6]]
  exploto <- exploto + lista4_entrada[[7]]
  cont_exitos[sample] <- cont_exitos[sample] + juego
  cont_tiradas[sample] <- cont_tiradas[sample] + 1
  lista4_entrada[[2]][sample] <- cont_exitos[sample] / cont_tiradas[sample]
  if(i==1){
    wins[i]=juego
  }else{
    wins[i]=wins[i-1]+juego
  }
}
alphas <- c(2+cont_exitos[1], 2+cont_exitos[2], 2+cont_exitos[3])
betas <- c(2+cont_tiradas[1]-cont_exitos[1],
           2+cont_tiradas[2]-cont_exitos[2],
           2+cont_tiradas[3]-cont_exitos[3])

# Graficos
graficar(cont_tiradas, cont_exitos, wins, alphas, betas)
print(paste("La ganancia de este año es ",wins[366],"unidades monetarias"))

```


Se observa que se utilizan las 3 máquinas de manera similar,tambien se puede notar que las tiradas en la máquina 2 presentan una proporción de éxitos mayor en comparación a las 2 restantes.
Viendo las distribuciones a posteriori se puede notar que al haberse realizado una cantidad de tiradas similiar en las 3 máquinas estas sus valores se encuentran concentrados alrededor del verdadero valor del parámetro ($\theta_1$,$\theta_2$,$\theta_3$).
Con el último gráfico se observa la evolución de las ganancias a traves del paso de los días, obteniendo una ganancia total de 170 unidades monetarias.

Luego se simulan 1000 años jugados con esta estrategia, esto se repite para tres valores distintos de $\epsilon = (0.05, 0.1, 0.2)$ y se comparan los resultados.

```{r}
###### 3 e distintos
graf_list <- list()
j=1
for (e in c(0.05, 0.2, 0.4)){
  wins4_anio=numeric(n_simulaciones)
  for (anio in 1:n_simulaciones) {
    # Defino variables necesarias
    tethas=c(0.3,0.55,0.45)
    t = c(0.5,0.5,0.5)
    cont_exitos= c(0,0,0) 
    cont_tiradas = c(0, 0, 0)
    juego=0
    sample=0
    exploro=0
    exploto=0
    
    wins=numeric(366)
    lista4_entrada=list(tethas, t, e, juego, sample, exploro, exploto)
    
    for(i in 1:366){
      lista4_entrada <- e_greedy_tasa_obs(lista4 = lista4_entrada)
      juego <- lista4_entrada[[4]]
      sample <- lista4_entrada[[5]]
      exploro <- exploro + lista4_entrada[[6]]
      exploto <- exploto + lista4_entrada[[7]]
      cont_exitos[sample] <- cont_exitos[sample] + juego
      cont_tiradas[sample] <- cont_tiradas[sample] + 1
      lista4_entrada[[2]][sample] <- cont_exitos[sample] / cont_tiradas[sample]
      if(i==1){
        wins[i]=juego
      }else{
        wins[i]=wins[i-1]+juego
      }
    }
    wins4_anio[anio]<-wins[366]
  }
  
  ganancia_df <- data.frame(wins = wins4_anio)
  graf_list[[j]] <-ggplot(ganancia_df) + #Reemplazar por boxplots
        aes(x = wins) +
        geom_histogram(aes(y = ..density..), color = "black", fill = "lightblue", bins = 30) +
        geom_density(color = "blue", size = 1)
  print(paste(mean(ganancia_df$wins)))
  j=j+1
}

grid.arrange(graf_list[[1]],
             graf_list[[2]],
             graf_list[[3]],
             ncol=1)

```

Luego de simular 1000 años, se grafican las ganancias anuales para los distintos valores de $\epsilon$, a traves de los mismos vemos distribuciones parecidas, todas centradas en aproximadamente 155 unidades monetarias.La ganancia media para los 1000 años de simulación tomando $\epsilon$ igual a 0.05,0.2 y 0.4 resultan 158.596,158.438 y 158.458 unidades monetarias respectivamente.
El método es bayesiano ya que utiliza la máquina con tasa de éxito mayor con probabilidad $1-\epsilon$, y elige una máquina de manera aleatoria con probabilidad $\epsilon$, y esta tasa de éxito se va modificando a traves de las tiradas.

#### *Estrategia 5: Softmax*

Dada la tasa observada para cada máquina i, $\pi_i$ se calcula una probabilidad de elegir cada máquina utilizando la función softmax:
$$Pr(i)=\frac{exp(\pi_i/\tau)}{\sum_{j=1}^{3}exp(\pi_i/\tau)}$$
donde $\tau$ es un parámetro de “temperatura” que controla el grado de exploración. Luego, se elige la máquina i con probabilidad $Pr(i)$ 
.
Se presenta la función "softmax" que para ciertos valores de las tasas ($\pi_i$) y el parámetro de temperatura ($\tau$), nos devuelve la probabilidad de utilizar cada una de las máquinas; y la función que replica esta estrategia para un día. A esta se le envia una lista con los parámetros necesarios. La función elige una máquina con probabilidad $Pr(i)$ , simula la jugada y luego nos devuelve los valores actualizados de los parámetros.

```{r, echo=TRUE, error=FALSE, warning=FALSE}
set.seed(491)
# Función softmax
softmax= function(tau,pi){
  pr_soft1 = exp(pi[1]/tau)/sum(exp(pi/tau))
  pr_soft2 = exp(pi[2]/tau)/sum(exp(pi/tau))
  pr_soft3 = exp(pi[3]/tau)/sum(exp(pi/tau))
  pr_soft = c(pr_soft1,pr_soft2,pr_soft3)
  return(pr_soft)
}

#Función para una tirada
tirada_softmax <- function(lista5){
  alphas <- lista5[[1]]
  betas <- lista5[[2]]
  tethas <- lista5[[3]]
  pi <- lista5[[4]]
  tau=0.1
  
  sample <- sample(1:3,1,prob=softmax(tau,pi))
  
  juego <- rbinom(1, 1, tethas[sample])
  alphas[sample] <- alphas[sample] + juego
  betas[sample] <- betas[sample] + 1 - juego
  
  lista5_salida<-list(alphas, betas, tethas,pi, juego,  sample)
  return(lista5_salida)
}
```

Reiterando este método para simular las jugadas de un año se obtiene:

```{r, echo=FALSE, error=FALSE, warning=FALSE}
# Defino variables necesarias
tethas=c(0.3,0.55,0.45)
alphas<-c(2,2,2)
betas<-c(2,2,2)
pi <- c(0.5,0.5,0.5)
cont_exitos= c(0,0,0) 
cont_tiradas = c(0, 0, 0)

wins=numeric(366)
lista5_entrada=list(alphas,betas, tethas,pi)

for(i in 1:366){
  lista5_entrada <- tirada_softmax(lista5_entrada)
  juego <- lista5_entrada[[5]]
  alphas <- lista5_entrada[[1]]
  betas <- lista5_entrada[[2]]
  sample <- lista5_entrada[[6]]
  cont_exitos[sample] = cont_exitos[sample] + juego 
  cont_tiradas[sample] = cont_tiradas[sample] + 1
  lista5_entrada[[4]][sample] <- cont_exitos[sample] / cont_tiradas[sample]
  if(i==1){
    wins[i]=juego
  }else{
    wins[i]=wins[i-1]+juego
  }
}

#Gráficos
graficar(cont_tiradas, cont_exitos, wins, alphas, betas)


```

Se observa que en el año simulado se utilizaron mayormente las máquinas 3 y 2, es decir, las máquinas que presentan una mayor probabilidad de éxito.
Por este motivo, vemos que los gráficos a posteriori que más se modificaron en comparación al prior son los de estas 2 máquinas, dichas distribuciones parecen concentrarse en su verdadero valor poblacional a medida que se juega más cantidad de veces con estas máquinas.
Mientras que el último gráfico evidencia la evolución diaria de las ganancias a lo largo del año, obteniendo una ganancia total igual a 211 unidades monetarias

Luego se repite este procedimiento para simular 1000 años jugados con esta estrategia y se analizan los resultados.

```{r, echo=FALSE, warning=FALSE, error=FALSE}
n_simulaciones=1000

wins5_anio=numeric(n_simulaciones)
for (anio in 1:n_simulaciones) {
  # Defino variables necesarias
  tethas=c(0.3,0.55,0.45)
  alphas<-c(2,2,2)
  betas<-c(2,2,2)
  pi <- c(0.5,0.5,0.5)
  cont_exitos= c(0,0,0) 
  cont_tiradas = c(0, 0, 0)
  
  wins=numeric(366)
  lista5_entrada=list(alphas,betas, tethas,pi)
  
  for(i in 1:366){
    lista5_entrada <- tirada_softmax(lista5_entrada)
    juego <- lista5_entrada[[5]]
    alphas <- lista5_entrada[[1]]
    betas <- lista5_entrada[[2]]
    sample <- lista5_entrada[[6]]
    cont_exitos[sample] = cont_exitos[sample] + juego 
    cont_tiradas[sample] = cont_tiradas[sample] + 1
    lista5_entrada[[4]][sample] <- cont_exitos[sample] / cont_tiradas[sample]
    if(i==1){
      wins[i]=juego
    }else{
      wins[i]=wins[i-1]+juego
    }
  }
  wins5_anio[anio]<-wins[366]
}

ganancia_df <- data.frame(wins = wins5_anio)
ggplot(ganancia_df) +
  aes(x = wins) +
  geom_histogram(aes(y = ..density..), color = "black", fill = "lightblue", bins = 30) +
  geom_density(color = "blue", size = 1)
```

A traves de la simulación de los 1000 años, se observa la distribución de las ganancias, la cual presenta un comportamiente levemente asimétrico por izquierda donde el 95% de los valores son mayores a 157 unidades monetarias.
La ganancia media anual resulta igual a 185.075 unidades monetarias.

```{r}
quantile(ganancia_df$wins,0.05)
mean(ganancia_df$wins)
```

El método utilizado es bayesiano, ya que, la elección de la máquina a utilizar se basa en una probabilidad que es función de las tasas observadas de éxito, las cuales van modificandose tirada a tirada.

#### *Estrategia 6: Upper-bound*

En esta estrategia se selecciona la máquina que tenga el mayor extremo derecho de un intervalo de credibilidad (construido a partir de la distribución a posteriori de la probabilidad de éxito).

Se presenta la función que simula esta estrategia para un día.Para esto se calculan los intervalos de credibilidad para las 3 distribuciones y se utiliza la máquina que presenta el mayor valor en el extremo derecho.Luego se simula el juego con la máquina elegida y se actualizan las distribuciones.

```{r, echo=TRUE, error=FALSE, warning=FALSE}
upper_bound <- function(lista6){
  tethas <- lista6[[1]]
  alphas <- lista6[[2]]
  betas <- lista6[[3]]
  
  UCB <- c(qbeta(0.95, alphas[1], betas[1]), 
           qbeta(0.95, alphas[2], betas[2]), 
           qbeta(0.95, alphas[3], betas[3]))
  sample <- order(UCB + runif(3, 0.001, 0.009), decreasing = TRUE)[1]
  juego <- rbinom(1, 1, tethas[sample])
  alphas[sample] <- alphas[sample] + juego
  betas[sample] <- betas[sample] + 1 - juego
  
  lista6_salida<-list(tethas, alphas, betas, UCB, juego, sample, cont_exitos, cont_tiradas)
  return(lista6_salida)
}
```

Reiterando este método para simular las jugadas de un año se obtiene:

```{r, echo=FALSE, error=FALSE, warning=FALSE}
# Defino variables necesarias
tethas=c(0.3,0.55,0.45)
cont_exitos= c(0,0,0) 
cont_tiradas = c(0, 0, 0)
juego=0
UCB <- c(0, 0, 0)
alphas <- c(2, 2, 2)
betas <- c(2, 2, 2)
wins <- c(0, 0, 0)
lista6_entrada <- list(tethas, alphas, betas, UCB, juego, sample, cont_exitos, cont_tiradas)

for(i in 1:366){
  lista6_entrada <- upper_bound(lista6 = lista6_entrada)
  juego <- lista6_entrada[[5]]
  alphas <- lista6_entrada[[2]]
  betas <- lista6_entrada[[3]]
  sample <- lista6_entrada[[6]]
  cont_exitos <- lista6_entrada[[7]]
  cont_tiradas <- lista6_entrada[[8]]
  cont_exitos[sample] = cont_exitos[sample] + juego 
  cont_tiradas[sample] = cont_tiradas[sample] + 1
  if(i==1){
    wins[i]=juego
  }else{
    wins[i]=wins[i-1]+juego
  }
}

#Graficos
graficar(cont_tiradas, cont_exitos, wins, alphas, betas)

```

Durante el año simulado se utilizó en mayor medida la máquina 2,la cual presenta una mayor probabilidad de éxito en una tirada.
El gráfico a posteriori de las máquinas 1 y 3 se ven levemente modificadas, mientras que dicha distribución para la máquina 2 presenta valores mucho más concentrados alrededor del verdadero valor del parámetro.
Por último se regristra la evolución diaria de las ganancias, obteniendo una ganancia total igual a 189 unidades monetarias.


Luego se repite este procedimiento para simular 1000 años jugados con esta estrategia y se analizan los resultados.

```{r, echo=FALSE, warning=FALSE, error=FALSE}
wins6_anio=numeric(n_simulaciones)
for (anio in 1:n_simulaciones) {
  # Defino variables necesarias
  tethas=c(0.3,0.55,0.45)
  alphas<-c(2,2,2)
  betas<-c(2,2,2)
  juego=0
  sample=0
  cont_exitos= c(0,0,0) 
  cont_tiradas = c(0, 0, 0)
  
  wins=numeric(366)
  lista6_entrada <- list(tethas, alphas, betas, UCB, juego, sample, cont_exitos, cont_tiradas)
  
  for(i in 1:366){
    lista6_entrada <- upper_bound(lista6 = lista6_entrada)
    juego <- lista6_entrada[[5]]
    alphas <- lista6_entrada[[2]]
    betas <- lista6_entrada[[3]]
    sample <- lista6_entrada[[6]]
    cont_exitos <- lista6_entrada[[7]]
    cont_tiradas <- lista6_entrada[[8]]
    cont_exitos[sample] = cont_exitos[sample] + juego 
    cont_tiradas[sample] = cont_tiradas[sample] + 1
    if(i==1){
      wins[i]=juego
    }else{
      wins[i]=wins[i-1]+juego
    }
  }
  wins6_anio[anio]<-wins[366]
}

ganancia_df <- data.frame(wins = wins6_anio)
ggplot(ganancia_df) +
  aes(x = wins) +
  geom_histogram(aes(y = ..density..), color = "black", fill = "lightblue", bins = 30) +
  geom_density(color = "blue", size = 1)
```

Mediante el gráfico de las ganancias anuales se observa una distribución unimodal, con una leve asimetría a la derecha en los cuales la ganancia se encuentra entre 167 y 211 unidades monetarias un 90% de las veces.La ganancia anual mediana resulta igual a 193 unidades monetarias
```{r}
quantile(ganancia_df$wins, c(0.02,0.95))
mean(ganancia_df$wins)
median(ganancia_df$wins)
```

El método utilizado para la elección de la máquina es bayesiano,ya que, actualiza la probabilidad de elección para cada maquina a medida que realiza las jugadas. En este caso, la distribución a posteriori se vera modificada y del mismo modo se modificaran los extremos derechos del intervalo de credibilidad.

#### *Estrategia 7: Thompson sampling*

En este método para seleccionar una máquina, se toma una muestra de la distribución a posteriori de las probabilidades de éxito de cada máquina y se elige la máquina correspondiente a la muestra más grande.

Se presenta la función que simula esta estrategia para un día.Para esto se obtienen 3 muestras aleatorias provenientes de las 3 distribuciones y se utiliza la máquina que presenta el mayor valor.Luego se simula el juego con la máquina elegida y se actualizan las distribuciones.

```{r, echo=TRUE, error=FALSE, warning=FALSE}
thompson_sampling <- function(lista7){
  alphas <- lista7[[1]]
  betas <- lista7[[2]]
  tethas <- lista7[[3]]
  muestra<- c(rbeta(1,alphas[1],betas[1]), 
               rbeta(1,alphas[2],betas[2]), 
               rbeta(1,alphas[3],betas[3]))
  #print(muestra)
  sample <- order(muestra, decreasing = TRUE)[1]
  juego <- rbinom(1, 1, tethas[sample])
  alphas[sample] <- alphas[sample] + juego
  betas[sample] <- betas[sample] + 1 - juego
  
  lista7_salida<-list(alphas, betas, tethas,  muestra, juego,  sample)
  return(lista7_salida)
}
```

Reiterando este método para simular las jugadas de un año se obtiene:

```{r, echo=FALSE, error=FALSE, warning=FALSE}
# Defino variables necesarias
alphas<-c(2,2,2)
betas<-c(2,2,2)
tethas=c(0.3,0.55,0.45)
wins=numeric(366)
cont_exitos= c(0,0,0)
cont_tiradas = c(0, 0, 0)
juego=0
sample=0
muestra=c()

lista7_entrada<-list(alphas, betas, tethas,  muestra, juego,  sample)

for(i in 1:366){
  lista7_entrada <- thompson_sampling( lista7_entrada )
  juego <- lista7_entrada[[5]]
  sample <- lista7_entrada[[6]]
  cont_exitos[sample] <- cont_exitos[sample] + juego
  cont_tiradas[sample] <- cont_tiradas[sample] + 1

  if(i==1){
    wins[i]=juego
  }else{
    wins[i]=wins[i-1]+juego
  }
}
alphas <- lista7_entrada[[1]]
betas <- lista7_entrada[[2]]
# Graficar
graficar(cont_tiradas, cont_exitos, wins, alphas, betas)

```

Se observa que a lo largo del año se utilizó mayormente las máquinas 2 y 3.
Las distribuciones a posteriori de las probabilidades de éxitos para estas máquinas se encuentran con más concentradas y centradas en los valores reales de los parámetros, mientras que la distribución de la máquina 1 no difiere tanto de la distribución a priori esto se debe a que fue la máquina menos utilizada.
El tercer gráfico presenta la evolución de las ganancias con el pasar de los días, se puede observar que la ganancia total resulta igual a 188 unidades monetarias.

Luego se repite este procedimiento para simular 1000 años jugados con esta estrategia y se analizan los resultados.

```{r, echo=FALSE, warning=FALSE, error=FALSE}
wins7_anio=numeric(n_simulaciones)
for (anio in 1:n_simulaciones) {
  alphas<-c(2,2,2)
  betas<-c(2,2,2)
  tethas=c(0.3,0.55,0.45)
  wins=numeric(366)
  cont_exitos= c(0,0,0)
  cont_tiradas = c(0, 0, 0)
  juego=0
  sample=0
  muestra=c()
  
  lista7_entrada<-list(alphas, betas, tethas,  muestra, juego,  sample)
  
  for(i in 1:366){
    lista7_entrada <- thompson_sampling( lista7_entrada )
    juego <- lista7_entrada[[5]]
    sample <- lista7_entrada[[6]]
    cont_exitos[sample] <- cont_exitos[sample] + juego
    cont_tiradas[sample] <- cont_tiradas[sample] + 1
    
    if(i==1){
      wins[i]=juego
    }else{
      wins[i]=wins[i-1]+juego
    }
  }
  wins7_anio[anio]<-wins[366]
}

ganancia_df <- data.frame(wins = wins7_anio)
ggplot(ganancia_df) +
  aes(x = wins) +
  geom_histogram(aes(y = ..density..), color = "black", fill = "lightblue", bins = 30) +
  geom_density(color = "blue", size = 1)

```

Se grafica la distribución aproximada de la ganancia anual. En este se diferencian un comportamiento simetrico centrado en aproximadamente 190 unidades monetarias.
La media de las ganancias anuales es 189.012 unidades monetarias.
Además se puede notar que mayormente se obtuvieron ganancias altas, por lo que suponemos que se utilizó en mayor medida la máquina dos.

El método utilizado es bayesiano, ya que, actualiza las distribuciones a posteriori en cada tirada, por lo que la muestra elegida provendrá de una distribución distinta.De esta manera la elección de la máquina estará influida por los resultados de las tiradas anteriores

##Conclusiones




