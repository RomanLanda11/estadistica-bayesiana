---
title: "Trabajo Pr치ctico 3"
author: "Gazze - Irisarri - Landa"
date: "2024-05-23"
output: html_document
---
```{r, include=FALSE, echo=FALSE}
#| label = Parametros del informe
modo_prod=FALSE
knitr::opts_chunk$set(fig.align = "center")
```

# Introducci칩n

Sumergirse en el mundo de la estad칤stica puede llevarnos a lugares inesperados, desafiando nuestras percepciones y llev치ndonos a explorar terrenos desconocidos. En esta ocasi칩n, nos sumergimos en un caso peculiar que fusiona el rigor anal칤tico con el misterio de una escena del crimen.

Nuestra historia se centra en Guido, un apasionado estudiante de estad칤stica cuyo amor por la resoluci칩n de enigmas lo llev칩 desde las aulas universitarias hasta las intrigantes calles de C칩rdoba.

Sin embargo, la emoci칩n de seguir su vocaci칩n se ve eclipsada por un oscuro suceso. En una madrugada envuelta en sombras, la unidad de trabajo de Guido es convocada de manera urgente para investigar un crimen reci칠n perpetrado en Salsipuedes. 

En medio del desorden, muebles destrozados, utensilios de cocina esparcidos y, en el centro de todo, el cuerpo inerte de Sergio Contreras, ba침ado en un charco de sangre. Ante esta escena, Guido se enfrenta a un desaf칤o crucial: determinar la hora en que se produjo la muerte.

![Imagen 1: Sergio minutos antes de su muerte](Imagen1.jpeg)

# Objetivos

El objetivo principal de este informe es utilizar m칠todos estad칤sticos con enfoque bayesiano para estimar con precisi칩n la hora de muerte de Sergio Contreras. A trav칠s del estudio de la temperatura corporal postmortem y la aplicaci칩n de modelos lineales, buscaremos proporcionar una estimaci칩n confiable del momento en que ocurri칩 el deceso. Adem치s, nuestro objetivo secundario es presentar los resultados de manera clara y concisa, demostrando un dominio completo del contenido y garantizando as칤 la obtenci칩n de una calificaci칩n sobresaliente (10游땔) en la evaluaci칩n del informe.

# Metodolog칤a

A trav칠s del an치lisis de la temperatura corporal, ecuaciones diferenciales y conceptos matem치ticos podremos descifrar el objetivo planteado. 

Sabemos que la temperatura del cuerpo de Segio satisface la siguiente ley:
 $$\frac{dT(t)}{dt}=r[T_{amb}-T(t)]$$
donde:

 * $T_{amb}$ es la temperatura ambiente (un valor fijo y conocido), 
 
 * $r$ es una constante y 
 
 * $T(t)$ es la funci칩n (en principio desconocida) que describe la temperatura del cuerpo en funci칩n del tiempo.

Se puede demostrar que Una funci칩n que satisface esa ecuaci칩n es $T(t)=T_{amb}+(T_i-T_{amb})e^{-rt}$
 
$$\frac{dT(t)}{dt}=\frac{d}{dt}(T(t)=T_{amb}+(T_i-T_{amb})e^{-rt})=$$
$$=(T_i-T_{amb})e^{-rt}(-r)=-r(T_i-T_{amb})e^{-rt}=$$
$$=-r(T_i-T_{amb})e^{-rt}+rT_{amb}-rT_{amb}=$$
$$=-r[(T_i-T_{amb})e^{-rt}+T_{amb}]+rT_{amb}=$$

$$=-r[T(t)-T_{amb}]=r[T_{amb}-T(t)]$$
donde:

 * $T_i$ la temperatura a la que est치 inicialmente el cuerpo de Sergio.
 
# Desarrollo

Para averiguar que indica la constante r, y que valores son coherentes, graficamos la funci칩n anterior para distintos valores de $r$, sabiendo que la temperatura del ambiente es $23춿C$ y la temperatura al momento de la muerte de Sergio es $37춿C$.
```{r, echo=FALSE, error=FALSE, warning=FALSE}
# Carga de paquetes
library(ggplot2)
library(gridExtra)
library(rstan)
library(bayesplot)
library(grid)
```

```{r echo=FALSE, error=FALSE, warning=FALSE}
valores_r = c(-0.1,-0.15, -0.3, 0, 0.1, 0.3, 1)
temp_desc <- function(valores_r){
  f <- c()
  r <- c()
  t <- seq(0, 24, length.out=200)
  for(i in 1:length(valores_r)){
    f <- c(f, 23+14*exp(valores_r[i]*t))  
    r <- c(r,rep(valores_r[i], time = 200))
  }
  df <- data.frame(f, tiempos = rep(t, time = length(r)), r=factor(r))
  
g1 <- ggplot(data = df) +
  aes(x = tiempos, y = f, color = r) +
  geom_line() +
  ylim(c(20, 60)) +
  scale_x_continuous(breaks = 0:24) +
  labs(
    x = "Hora post mortem", 
    y = "Temperatura corporal",
    caption = "Gr치fico 1: Temperatura corporal post mortem para distintos valores de r"
  ) +
  scale_color_manual(
    values = c("#BF0404","cyan", "#010326", "#0D0D0D", "#717362", "#7d721a", "#8C2E2E")
  ) +
  #theme_minimal() +  # Utilizar un tema minimalista para una apariencia m치s limpia
  theme(
    plot.caption = element_text(hjust = 0.5)
  )
  g1
}
temp_desc(valores_r)
```
 
Sabemos que la temperatura corporal eventualmente alcanza el equilibrio t칠rmico con el ambiente, por lo que no desciende m치s de $23춿C$. Adem치s, al observar los gr치ficos, se puede deducir que $r$ representa la rapidez con la que la temperatura corporal disminuye hasta igualarse con la del entorno. Por este motivo, el valor de $r$ no puede ser negativo, ya que en estos casos la temperatura aumenta y no es coherente en este problema.

En t칠rminos generales, el cad치ver pierde $2 춿C$ de temperatura durante la primera hora despu칠s del deceso. Luego pierde alrededor de $1.5 춿C$ por hora durante las siguientes 12 horas. En las horas posteriores, la temperatura desacelera su descenso hasta llegar a la temperatura ambiente, aproximadamente 24 hs luego de la muerte.

Por lo tanto, llegamos a la conclusi칩n de que $0.15$ es un valor l칩gico para $r$, ya que en las primer hora vemos una disminuci칩n de $1.95춿C$ en la temperatura corporal, luego, para las siguientes 12 horas la temperatura descendera en raz칩n de entre $1춿C$ y $1.5춿C$ por hora. Posteriormente la temperatura seguir치 descendiendo de manera m치s lenta hasta llegar a la temperatura ambiente aproximadamente 24hs despues de la muerte.
 
 
Para responder nuestro objetivo tendremos en cuenta las siguientes consideraciones:
En lugar de considerar la temperatura del cuerpo, se considerar치 la diferencia entre la temperatura del cuerpo y la temperatura ambiente $(T-T_{amb})$. Adem치s, se llamar치 $T_{diff}$ a la diferencia entre la temperatura inicial del cuerpo y la temperatura ambiente $(T_i-T_{amb})$.

$$T(t)-T_{amb}=T_{diff}e^{-rt}$$

Para linealizar la ecuaci칩n aplicamos logaritmo natural a nuestra nueva variables $T(t)-T_{amb}$
$$ln(T(t)-T_{amb})=ln(T_{diff})-rt$$
Mostramos esto graficamente utilizando $r = 0.15$:

```{r,  echo=FALSE}
r = 0.15
t <- seq(0, 24, length.out=200)
f <- 14*exp(-r*t)
ln_f <- log(f)
df2 <- data.frame(f = c(f,ln_f),t =c(t,t), funcion = rep(c("f", "ln_f"), each = 200))
g4 <- ggplot(data = df2) +
  aes(x = t, y = f, color = funcion) +
  geom_line() +
  labs(
    x = "Hora post mortem", 
    y = "Grados cent칤grados", 
    caption = expression("Gr치fico 2: Comparaci칩n de las funciones " * T(t) - T[amb] * " y " * log(T(t) - T[amb])),
    color = "Funci칩n"  # Cambia el t칤tulo de la leyenda a may칰sculas
  ) +
  scale_color_manual(
    values = c("#B10504", "#47421E"),
    labels = c(expression(T(t) - T[amb]), expression(log(T(t) - T[amb])))
  ) +
  #theme_minimal() +  # Utilizar un tema minimalista para una apariencia m치s limpia
  theme(
    plot.caption = element_text(hjust = 0.5),
    legend.title = element_text(face = "bold"),  # Poner el t칤tulo de la leyenda en negrita
    legend.text = element_text(size = 10)        # Ajustar el tama침o del texto de la leyenda
  )
g4
```
 
 El intercepto de la funci칩n logaritmo de $T(t)-T_{amb}$ es $ln(T_{diff})=2.639$ , lo que indica que la diferencia entre la temperatura corporal y la temperatura ambiente en el momento de la muerte es $e^{2.639}춿C=14춿C$. La pendiente es $-r=-0.13$, esto significa que a medida que aumenta una hora, el logaritmo de la diferencia entre la temperatura corporal y la temperatura ambiente disminuye en $0.1춿C$.
 
Para resolver nuestro objetivo proponemos ajustar un modelo lineal normal, en el que tomaremos como variable explicativa el tiempo.
A continuaci칩n se presentan los hechos transcurridos en la noche del fallecimiento de Sergio para ingresar estos datos en el modelo.

![Imagen 2: Cronolog칤a de los hechos](linea_tiempo.png)
Para deducir un prior para el intercepto suponemos que la verdadera funci칩n que describe el descenso de temperatura post mortem ( **algor mortis** ) es aquella que presentamos con $r=0.15$. Luego, tomamos las medidciones de las 6:45 am y 8:15 am, las proyectamos a traves de nuestra funci칩n y obsevarmos cuantas horas transcurrieron desde la muerte.

```{r,  echo=FALSE}
valores_r = c(0.15)
f <- c()
r <- c()
t <- seq(0, 12, length.out=100)
for(i in 1:length(valores_r)){
  f <- c(f, 22+15*exp(-valores_r[i]*t))
  r <- c(r,rep(valores_r[i], time = 100))
}
  
df <- data.frame(f, tiempos = rep(t, time = length(r)), r=factor(r))

g1 <- ggplot(data = df) +
    aes(x = tiempos, y = f) +
    geom_line(color = "#BF0404") + # Color fijo para r = 0.1
    ylim(c(20, 40)) +
    scale_x_continuous(breaks = seq(0, 12, by = 1), labels = seq(0, 12, by = 1)) +
    labs(
      x = "Hora post mortem",
      y = "Temperatura corporal",
      caption = "Gr치fico 3: Temperatura corporal post mortem para r = 0.15"
    ) +
    # A침adir l칤neas horizontales
    geom_hline(yintercept = 32.8, linetype = "dashed", color = "blue") +
    geom_hline(yintercept = 30.5, linetype = "dashed", color = "green") +
    geom_vline(xintercept = (log((32.8-22)/15)/-0.15), linetype = "dashed", color = "blue") +
    geom_vline(xintercept = (log((30.5-22)/15)/-0.15), linetype = "dashed", color = "green") +
    theme(plot.caption = element_text(hjust = 0.5))
print(g1)
  #log((32.8-22)/15)/-0.15
  #log((30.5-22)/15)/-0.15)

```
Viendo esto sabemos que a las 6:45 am el cuerpo deberia llevar 2.19 horas sin vida y a las 8:45 am 3,786 horas (lo que equivale a 2 hs y 12 minutos, y 3 hs y 47 minutos respectivamente). Por lo que pensamos que la hora de muerte puede estas alrededor de las 4:30 am. 

 Modelo:

 $Y_i| \beta_0, \beta_1, \sigma \sim N (\mu_i, \sigma)$
 $\mu_i = \beta_0 + \beta_1t$
 $\beta_0 \sim N(\mu=2.7, \sigma=0.05)$
 $\beta_1 \sim N(\mu=-0.13, \sigma_2=0.03)$
 $\sigma \sim N^+ (\theta_2=1)$

Donde:

 * $Y_i=log(T(t)-T_{amb})$
 
 * $\beta_0$: es el intercepto de la recta
 
 * $\beta_1$: es la pendiente de la recta
 
 * $\sigma$: desv칤o est치ndar de $Y_i$
 
 * $t$: minutos transcurridos desde la muerte de Sergio Contreras.
 
Hacemos el supuesto de que los par치metros son independientes, por lo que podemos postular un prior marginal para cada uno. 
Adem치s pensamos que la muerte de Sergio ocurri칩 en un horario cercano al ya mencionado (4:30am), y tendremos en cuenta esto para deducir nuestras distribuciones a priori.

Para definir el prior de $\beta_0$ sabemos que la temperatura habitual del cuerpo humano oscila como mucho entre $36춿C$ y $38춿C$, y la temperatura ambiente en Salsipuedes esa noche fue de $22춿C$, pensamos que $\beta_0$ puede variar aproximadamente entre $log(38 - 22)=2.773$ y $log(36 - 22)=2.639$. Por lo que nuestro prior para este par치metro es una distribuci칩n normal con media igual a 2.7 y desv칤o 0.05.

Para definir el prior de $\beta_1$ asumimos que la pendiente no puede ser positiva, ya que la diferencia entre la temperatura de un cuerpo sin vida y la temperatura ambiente ir치 disminuyendo conforme pasen las horas. Por lo tanto, asumimos un prior de $\beta_1$ con distribuci칩n Normal con media $\mu = -0.15$ y desv칤o $\theta_1 = 0.04$.

Por 칰ltimo como $\sigma$ no puede tomar valores negativos, decidimos postular una distribuci칩n Media Normal Positiva con desv칤o $\theta_2 = 1$ porque pensamos que el logaritmo de las diferencias de temperaturas pueden estar como mucho entre 0 y 3.

Mostramos graficamente los prior mencionados:
 
```{r,  echo=FALSE}
t <- seq(from = -1, to = 24, length.out = 200)
muestras_bo = rnorm(200,2.7, 0.05)
muestras_b1 = rnorm(200,-0.15, 0.04)


df= data.frame(muestras_bo,muestras_b1)

df_aux <- data.frame(b0=rep(muestras_bo, each=200), 
                     b1=rep(muestras_b1, each=200),
                     tiempo=rep(t, times=200),
                     curva=factor(rep(1:200, each=200)))
df_aux$tdt <- exp(df_aux$b0+df_aux$b1*df_aux$tiempo)+22

tdt_graf <- ggplot(df_aux)+
  aes(x = tiempo, y = tdt, group = curva)+
  geom_line(alpha = 0.1, color = "gray2")+
  theme(legend.position = "none")+
  labs(x = expression("Tiempo en horas (" * T[i] * ")"), y = expression(T(t)))+
  geom_vline(xintercept = 0, linetype = "dashed", color = "blue")+
  scale_x_continuous(breaks = seq(-2, 24, by = 2), labels = seq(-2, 24, by = 2)) +
  scale_y_continuous(breaks = seq(20, 50, by = 2), labels = seq(20, 50, by = 2))+
  geom_hline(yintercept = 37.5, linetype = "dashed", color = "red")+
  geom_hline(yintercept = 36.5, linetype = "dashed", color = "red")
#tdt_graf

valores_rectas=muestras_bo + muestras_b1*t
sigma = abs(rnorm(200,0,1))

# Crear un rango para t

y <- seq(from = 0, to = 3, length.out = 200)
#df2 <- data.frame(t, y)

g <- ggplot(df, aes(x = t, y = y)) +
  geom_point(alpha = 0)+
  labs(
    x = expression("Tiempo en horas (" * T[i] * ")"),
    y = expression( Log( T(t) - T[amb] ) ),
    #caption = expression("Gr치fico 3: Priors para beta_0 y beta_1")
  ) + # TODO: Poner expresi칩n
  geom_abline(intercept = muestras_bo, slope = muestras_b1, alpha = 0.1, color = "gray3") +
  coord_cartesian(xlim = c(-2, 24), ylim = c(0, 3))+  
  scale_x_continuous(breaks = seq(-2, 24, by = 2), labels = seq(-2, 24, by = 2)) +  # A침ade valores al eje x
  scale_y_continuous(breaks = seq(0, 3, by = 0.5), labels = seq(0, 3, by = 0.5)) +  # A침ade valores al eje y
 theme(plot.caption = element_text(hjust = 0.5))
# Mostrar el gr치fico
#g
#TODO: Graficar las curcas correspondientes a estos priors

grid.arrange(g, tdt_graf, ncol = 2,
             botton = textGrob("Gr치fico 4: Priors",
                            x = 1,
                            just = "center"))
```

Basandonos en los priors mencionados y el supuesto de par치metros independientes, podemos obtener la distribuci칩n predictiva a priori a trav칠s de muestras. Para realizar esto se toman valores puntuales de t. 

```{r,  echo=FALSE}
generar_datos <- function(t) {
  muestras_bo <- rnorm(200, 2.7, 0.05)
  muestras_b1 <- rnorm(200, -0.15, 0.04) #trampa
  sigma <- abs(rnorm(200, 0, 1))
  mu <- muestras_bo + muestras_b1 * t
  y_pred <- rnorm(200, mu, sigma)
  return(data.frame(t = t, y_pred = y_pred))
}

tiempos <- c(0, 6, 12, 24)

df_muestras <- data.frame()

for (t in tiempos) {
  df_muestras <- rbind(df_muestras, generar_datos(t))
}

ggplot(df_muestras, aes(x = y_pred)) +
  geom_histogram(bins = 20, fill = "#897289", color = "black", alpha = 0.7) +
  facet_wrap(~ t, nrow = 2, scales = "fixed") +  # Crear facetas con dos filas
  labs(
    x = "Predicciones",
    y = "Frecuencia",
    title = "Distribuci칩n de las predicciones para diferentes tiempos",
    caption = "Gr치fico 5: Histograma de y_pred para t = 0, 6, 12 y 24"
  ) +
  scale_x_continuous(breaks = seq(floor(min(df_muestras$y_pred)), ceiling(max(df_muestras$y_pred)), by = 1))  # A침adir cortes de a 1 en el eje x
  #theme(plot.caption = element_text(hjust = 0.5))

# TODO: interpretar y pasar a temperatura
```



```{r,  echo=FALSE}
#Modelo para un dato
if(modo_prod){
  N <- 1
  y <- array(log(32.8-22),dim=1)
  x <- array(1.2,dim=1)
  stan_data <- list(N=1,x=x,y=y)
  stan_model <- stan( 
      file ="modelo_tp.stan", 
      chains = 4,          # Cantidad de cadenas
      warmup = 100,
      data = stan_data,
      model_name = "modelo_tp",
      seed = 12119       # Para que el resultado sea reproducible
  )
  save(stan_model, file="modelo1.RData")
}
load("modelo1.RData")
stan_model # TODO: beta1 da muy chico, est치 bien??

df_draws_1 <- as.data.frame(extract(stan_model))

colores1 <- c("#da91d5","#663364", "#897289", "purple", "#7e0b7d", "#9e3d9d")
colores2 <- c("#897289", "#897289", "#897289", "#663364", "#897289", "#663364")

color_scheme_set(colores1)
mcmc_trace(
  stan_model,
  pars = c("beta0", "beta1", "sigma"),
#  facet_args = list(nrow = 3)
  facet_args = list(nrow = 2, labeller = label_parsed))
#  labs(caption = "Gr치fico 6: trace plot de las muestras") +
#    theme(plot.caption = element_text(hjust = 0.5)))

color_scheme_set(colores2)
hist1 <- mcmc_hist(
  stan_model,
  pars = c("beta0", "beta1", "sigma"),
# div_color = "#897289",
  facet_args = list(nrow = 3))+
  scale_color_manual(values = c("#897289"))
hist1
dens1 <- mcmc_dens_overlay(stan_model, pars = c("beta0", "beta1", "sigma"))

```


```{r,  echo=FALSE}
set.seed(511) 
t= seq(-1,24, length.out=200)
# Filtrar 200 filas aleatorias
df_sampled <- df_draws_1[sample(nrow(df_draws_1), 200), ]
posterior1= ggplot() +
  labs(
    x = expression("Tiempo (" * T[i] * ")"),
    y = expression( Log( T(t) - T[amb] ) ),
    caption = expression("Gr치fico 3: Priors para beta_0 y beta_1")
  ) + # TODO: Poner expresi칩n
  geom_abline(intercept = df_sampled$beta0, slope = df_sampled$beta1, alpha = 0.1, color = "grey3") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "#7e0b7d")+
  coord_cartesian(xlim = c(0, 24), ylim = c(0, 3))+  
  scale_x_continuous(breaks = seq(0, 24, by = 1), labels = seq(0, 24, by = 1)) +  # A침ade valores al eje x
  scale_y_continuous(breaks = seq(0, 3, by = 0.5), labels = seq(0, 3, by = 0.5)) +
  geom_point(aes(x = 1.2, y = 2.3795), fill = "purple", color = "#7e0b7d", size = 2, shape = 21)+
 theme(plot.caption = element_text(hjust = 0.5))

df_aux <- data.frame(b0=rep(df_sampled$beta0, each=200), 
                     b1=rep(df_sampled$beta1, each=200),
                     tiempo=rep(t, times=200),
                     curva=factor(rep(1:200, each=200)))
df_aux$tdt <- exp(df_aux$b0+df_aux$b1*df_aux$tiempo)+22

tdt_graf <- ggplot(df_aux)+
  aes(x = tiempo, y = tdt, group = curva)+
  geom_rect(aes(ymin=36.5, ymax=37.5, xmin=-2, xmax=24),fill = "purple", alpha=0.01)+
  geom_line(alpha = 0.1, color = "gray2")+
  theme(legend.position = "none")+
  labs(x = "Tiempo (horas)", y = expression(T(t)))+
  geom_vline(xintercept = 0, linetype = "dashed", color = "#7e0b7d")+
  scale_x_continuous(breaks = seq(-1, 24, by = 2), labels = seq(-1, 24, by = 2)) +
  scale_y_continuous(breaks = seq(20, 50, by = 2), labels = seq(20, 50, by = 2))+
  geom_point(aes(x = 1.2, y = 32.8), fill = "purple", color = "#7e0b7d", size = 2, shape = 21)


grid.arrange(posterior1, tdt_graf, ncol=2,
             botton = textGrob("Gr치fico 7: Posteriors de un dato",
                            x = 1,
                            just = "center"))
```

```{r,  echo=FALSE}
#Vamos a calcular la distribuci칩n de t para la temperatura corporal de 37 grados

df_draws_1$t_muerte <- log(15/exp(df_draws_1$beta0))/(-df_draws_1$beta1)

ggplot(df_draws_1)+
  aes(x = t_muerte)+
  geom_histogram(bins = 20, fill = "#897289", color = "black", alpha = 0.7)
  # #geom_label(aes(x = 0, y = 0,
  #               label = "Media = 0.225"),
  #           stat = "unique")
mean(df_draws_1$t_muerte)
```

```{r,  echo=FALSE}
#Modelo con 2 datos
if(modo_prod){
  N <- 2
  y <- array(c(log(32.8-22),log(30.5-22)),dim=2)
  x <- array(c(1.2,2.7),dim=2)
  stan_data <- list(N=2,x=x,y=y)
  stan_model_2 <- stan( 
      file ="modelo_tp.stan", 
      chains = 4,         # Cantidad de cadenas
      warmup = 100,
      data = stan_data,
      model_name = "modelo_tp",
      seed = 12119       # Para que el resultado sea reproducible
  )
  stan_model_2
  save(stan_model_2, file="modelo2.RData")
}
load("modelo2.RData")

df_draws_2 <- as.data.frame(extract(stan_model_2))

colores1 <- c("#da91d5","#663364", "#897289", "purple", "#7e0b7d", "#9e3d9d")
colores2 <- c("#897289", "#897289", "#897289", "#663364", "#897289", "#663364")

color_scheme_set(colores1)

mcmc_trace(
  stan_model_2,
  pars = c("beta0", "beta1", "sigma"),
  facet_args = list(nrow = 3)
)
color_scheme_set(colores2)

mcmc_hist(
  stan_model_2,
  pars = c("beta0", "beta1", "sigma"),
  facet_args = list(nrow = 3)
)
```

```{r,  echo=FALSE}
set.seed(511) 
# Filtrar 200 filas aleatorias
df_sampled <- df_draws_2[sample(nrow(df_draws_2), 200), ]
posterior2= ggplot() +
  labs(
    x = expression("Tiempo (" * T[i] * ")"),
    y = expression( Log( T(t) - T[amb] ) ),
    caption = expression("Gr치fico 3: Priors para beta_0 y beta_1")
  ) + # TODO: Poner expresi칩n
  geom_abline(intercept = df_sampled$beta0, slope = df_sampled$beta1, alpha = 0.1, color = "grey3") +
  coord_cartesian(xlim = c(0, 24), ylim = c(0, 3))+  
  scale_x_continuous(breaks = seq(-2, 24, by = 2), labels = seq(-2, 24, by = 2)) +
  scale_y_continuous(breaks = seq(0, 3, by = 0.5), labels = seq(0, 3, by = 0.5))+
  geom_vline(xintercept = 0, linetype = "dashed", color = "#7e0b7d")+
  geom_point(aes(x = c(1.2,2.7), y = c(2.3795,2.14)), fill = "purple", color = "#7e0b7d", size = 2, shape = 21)+
 theme(plot.caption = element_text(hjust = 0.5))

df_aux <- data.frame(b0=rep(df_sampled$beta0, each=200), 
                     b1=rep(df_sampled$beta1, each=200),
                     tiempo=rep(t, times=200),
                     curva=factor(rep(1:200, each=200)))
df_aux$tdt <- exp(df_aux$b0+df_aux$b1*df_aux$tiempo)+22

tdt_graf <- ggplot(df_aux)+
  aes(x = tiempo, y = tdt, group = curva)+
  geom_rect(aes(ymin=36.5, ymax=37.5, xmin=-2, xmax=24),fill = "purple", alpha=0.01)+
  geom_line(alpha = 0.1, color = "gray2")+
  theme(legend.position = "none")+
  labs(x = "Tiempo (horas)", y = expression(T(t)))+
  geom_vline(xintercept = 0, linetype = "dashed", color = "#7e0b7d")+
  scale_x_continuous(breaks = seq(-2, 24, by = 2), labels = seq(-2, 24, by = 2)) +
  scale_y_continuous(breaks = seq(20, 50, by = 2), labels = seq(20, 50, by = 2))+
  geom_point(aes(x = 1.2, y = 32.8), fill = "purple", color = "#7e0b7d", size = 2, shape = 21)+
  geom_point(aes(x = 2.7, y = 30.5), fill = "purple", color = "#7e0b7d", size = 2, shape = 21)

grid.arrange(posterior2,tdt_graf, ncol=2,
             botton = textGrob("Gr치fico ?: Posteriors para dos datos",
                            x = 1,
                            just = "center"))
```

```{r,  echo=FALSE}
df_draws_2$t_muerte <- log(15/exp(df_draws_2$beta0))/(-df_draws_2$beta1)
ggplot(df_draws_2)+
  aes(x = t_muerte)+
  geom_histogram(bins = 20, fill = "#897289", color = "black", alpha = 0.7)
mean(df_draws_2$t_muerte)
```


```{r,  echo=FALSE}
if(modo_prod){
  N <- 3
  y <- array(c(log(32.8-22),log(30.5-22),log(23.7-22)),dim=3)
  x <- array(c(1.2,2.7,7.95),dim=3)
  stan_data <- list(N=3,x=x,y=y)
  stan_model_3 <- stan( 
      file ="modelo_tp.stan", 
      chains = 4,         # Cantidad de cadenas
      warmup = 100,
      data = stan_data,
      model_name = "modelo_tp",
      seed = 12119       # Para que el resultado sea reproducible
  )
  stan_model_3
  save(stan_model_3, file="modelo3.RData")
}
load("modelo3.RData")
stan_model_3 # TODO: beta1 da muy chico, est치 bien??

df_draws_3 <- as.data.frame(extract(stan_model_3))
color_scheme_set(colores1)

mcmc_trace(
  stan_model_3,
  pars = c("beta0", "beta1", "sigma"),
  facet_args = list(nrow = 3)
)
color_scheme_set(colores2)

mcmc_hist(
  stan_model_3,
  pars = c("beta0", "beta1", "sigma"),
  facet_args = list(nrow = 3)
)
```
```{r,  echo=FALSE}
set.seed(511) 
# Filtrar 200 filas aleatorias
df_sampled <- df_draws_2[sample(nrow(df_draws_3), 200), ]
posterior3 =ggplot() +
  labs(
    x = expression("Tiempo (" * T[i] * ")"),
    y = expression( Log( T(t) - T[amb] ) )) + # TODO: Poner expresi칩n
  geom_abline(intercept = df_sampled$beta0, slope = df_sampled$beta1, alpha = 0.1, color = "grey3") +
  coord_cartesian(xlim = c(0, 24), ylim = c(0, 3))+  
  scale_x_continuous(breaks = seq(0, 24, by = 1), labels = seq(0, 24, by = 1)) +  # A침ade valores al eje x
  scale_y_continuous(breaks = seq(0, 3, by = 0.5), labels = seq(0, 3, by = 0.5)) +  # A침ade valores al eje y
  geom_point(aes(x = c(1.2,2.7, 7.95), y = c(2.3795,2.14, 0.5606 )), fill = "purple", color = "#7e0b7d", size = 2, shape = 21)+
  geom_vline(xintercept = 0, linetype = "dashed", color = "#7e0b7d")+
 theme(plot.caption = element_text(hjust = 0.5))

df_aux <- data.frame(b0=rep(df_sampled$beta0, each=200), 
                     b1=rep(df_sampled$beta1, each=200),
                     tiempo=rep(t, times=200),
                     curva=factor(rep(1:200, each=200)))
df_aux$tdt <- exp(df_aux$b0+df_aux$b1*df_aux$tiempo)+22

tdt_graf <- ggplot(df_aux)+
  aes(x = tiempo, y = tdt, group = curva)+
  geom_rect(aes(ymin=36.5, ymax=37.5, xmin=-2, xmax=24),fill = "purple", alpha=0.01)+
  geom_line(alpha = 0.1, color = "gray2")+
  theme(legend.position = "none")+
  labs(x = "Tiempo (horas)", y = expression(T(t)))+
  geom_vline(xintercept = 0, linetype = "dashed", color = "#7e0b7d")+
  scale_x_continuous(breaks = seq(-2, 24, by = 2), labels = seq(-2, 24, by = 2)) +
  scale_y_continuous(breaks = seq(20, 50, by = 2), labels = seq(20, 50, by = 2))+
  geom_point(aes(x = 1.2, y = 32.8),  fill = "purple", color = "#7e0b7d", size = 2, shape = 21)+
  geom_point(aes(x = 2.7, y = 30.5),  fill = "purple", color = "#7e0b7d", size = 2, shape = 21)+
  geom_point(aes(x = 7.95, y = 23.7),  fill = "purple", color = "#7e0b7d", size = 2, shape = 21)

grid.arrange(posterior3, tdt_graf, ncol=2,
             botton = textGrob("Gr치fico ?: Posteriors para tres datos",
                            x = 1,
                            just = "center"))
```

Cada morgue cuenta con salas o cuartos destinados a la recepci칩n y almacenamiento de los cuerpos. Cada una de ellas debe estar correctamente refrigerada y, en funci칩n de sus condiciones t칠rmicas, se clasifican en dos tipos: de temperatura sobre cero y de temperatura bajo cero.!!!!!
 
```{r,  echo=FALSE}
df_draws_3$t_muerte <- log(15/exp(df_draws_3$beta0))/(-df_draws_3$beta1)
ggplot(df_draws_3)+
  aes(x = t_muerte)+
  geom_histogram(bins = 20, fill = "#897289", color = "black", alpha = 0.7)
mean(df_draws_3$t_muerte)

```
 


 
 